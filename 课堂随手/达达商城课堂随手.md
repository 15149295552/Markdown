[TOC]

# PROJECT-DAY01

## 一、介绍

* 目的
  * 从事Python开发工程师岗位。
  * 作为其他岗位的附加技能。
* 特点
  * 综合：装饰器、类、MySQL数据库、Redis数据库、进程、线程、协程、Django框架、Web前端、django-redis、django对事物支持、Celery框架、第三方短信平台、第三方登录平台、第三方支付平台... ...
  * 代码量相对较大，排错相对困难
  * 根据实战性：依据API文档进行开发

## 二、前后端分离

### 1）前后端分离流程

* 前端服务器（<font color=red>Nginx</font>）

  处理客户端所有请求，返回html、css、js，但是没有具体数据。

* 后端服务器（<font color=red>Django</font>）

  专门负责业务逻辑处理和数据返回（<font color=red>return JsonResponse({"code": 200, "data": []})</font>）。

* 前后端分离与不分离流程图

  ![](./images/01_前后端分离和不分离.png)

### 2）判断前后端分离的标准

* 项目中是否使用模板层，前后端分离后相当于把 MTV 中的 T 给分离出去。
* 分离后，所有的视图函数返回值均为：return JsonResponse({})

### 3）前后端分离优点

* 前后端并行开发，效率高。
* 一个后端可以灵活搭配各类前端，比如安卓、IOS、PC端。
* 有效利用客户端设备，减少服务器端压力。

## 三、编码和加密

### 1）BASE64编码

* 关于base64

  * base64不是加密，只是一种编码技术。

  * base64编码后的长度一定是4的倍数。
  * base64编码后的结果末尾可能会有 0个、1个、2个 等于号。
  * 编码过程：首先将字符串拆分为每三个字符一组，计算每个字符ASCII码对应的二进制，再按照每6位一组重新分组，计算对应的十进制，最后根据base64对照表得到base64编码的结果。

* 常用方法

  * base64.b64encode()
  * base64.b64decode()
  * base64.urlsafe_b64encode()
  * base64.urlsafe_b64decode()

  <font color=red>base64模块中所有方法的参数和结果都是字节串，项目中一旦使用base64编码，一定要注意 encode() 和 decode() 使用！</font>

### 2）SHA256

* 哈希三大特性

  不可逆、定长输出、雪崩

* 加密算法应用

  如果加密的结果用于存储，使用md5加密，比如：密码

  如果加密的结果用于计算，使用SHA系列，比如：JWT

* 实例

  ```python
  import hashlib
  
  s = hashlib.sha256()
  s.update("xxx".encode())
  s.hexdigest()  # 十六进制加密结果：string
  ```

### 3）HMAC-SHA256

* 用于校验数据的完整性和来源性

* 示例

  ```python
  import hmac
  
  r = hmac.new(key, msg, digestmod="SHA256").hexdigest()
  ```

## 四、JWT

* jwt流程图

  ![](./images/02_token流程图.png)

* 作用

  <font color=red>会话保持。</font>

* JWT三大组成部分
  * header：{"alg": "HS256", "typ": "JWT"}

    对该部分进行base64编码!

  * payload: {"exp": xxx, "username": xxx}

    对该部分进行base64编码!

  * sign

    1. 对前两部分的和进行hmac-sha256加密；
    2. 再对加密后的结果进行base64编码.

* pyjwt模块

  `import jwt`

  1. 生成token

     `token = jwt.encode(payload, key, algorithm="HS256")`

  2. 校验token

     `payload = jwt.decode(token, key, algorithms="HS256")`

  <font color=green>**jwt模块非常强硬，一旦token校验失败，则会抛出异常；所以后期在项目中只要用到了token的校验，则一定要加try语句。**</font>

## 五、前后端分离环境搭建

### 1）前端环境

* 安装并启动Nginx

* 创建项目配置文件：**/etc/nginx/conf.d/dadashop.conf**

  指定监听端口7000， 设置根目录 /var/www/html/

* 拷贝前端文件到指定目录

  **/var/www/html/dadashop/templates/index.html**

### 2）后端环境

#### http://127.0.0.1:7000/dadashop/templates/index.html





#### 离线安装模块

1. 官网下载安装包

2. 解压并cd到解压后的目录

   tar -zxvf  xxx.tar.gz

3. 安装：sudo python3 setup.py install



* 思考整个流程
  * 发邮件（<font color=red>后端</font>）：`from django.core import mail`
  * 激活链接（<font color=red>前端</font>）：`http://127.0.0.1:7000/dadashop/templates/active.html`
  * 激活页面（<font color=red>前端</font>）：`非常漂亮的激活页面`
  * 激活用户（<font color=red>后端</font>）：`is_active=True`

* 关于激活链接体现用户标识问题

  <font color=red>激活链接中通过查询字符串体现用户标识，用于后期激活用户功能。</font>

  * **?code=zhaoliying**   
  * **?code=base64(b"zhaoliying")**
  * **?code=base64(b"1016_zhaoliying")**

* 随机数存储在哪里？

  Redis数据库：{"active_zhaoliying": 1016}

  激活有效期3天：Redis设置有效期



django_redis组件









```python
ksaubzkrslrvbggb
```







## 整体设计

### 响应内容

正确响应：{"code": 200, .........}

错误响应：{"code": 错误状态码, "error": "错误原因"}



* 用户模块（**users**）

  错误状态码：10100 ~ 10199

  路由设计： v1/users/

* 商品模块（**goods**）

  错误状态码：10200 ~ 10299

  路由设计： v1/goods/

* 购物车模块（**carts**）

  错误状态码：10300 ~ 10399

  路由设计： v1/carts/

* 订单模块（**orders**）

  错误状态码：10400 ~ 10499

  路由设计： v1/orders/

* 支付模块（**pays**）

  错误状态码：10500 ~ 10599

  路由设计： v1/pays/









